function data_decoded = huffman_decode(data_encoded,code)
% HUFFMAN_DECODE --- Huffman decoding
% CMP Vision Algorithms http://visionbook.felk.cvut.cz
%
% Usage: data_decoded = huffman_decode(data_encoded,code)
% Inputs:
%   data_encoded  [m x 1]  
%     Binary encoded message of class logical, produced by 
%     function huffman_encode.
%   code  struct  Huffman code generated by huffman. 
%     This must be the same code used for encoding, otherwise the
%     result is garbage.
% Outputs:
%   data_decoded  [n x 1]  Decoded message.
% See also: huffman, huffman_encode.

% Decoding consists of starting at the root of the coding tree
% and descending by left or right branches, depending on whether the
% input symbol is 0 or 1. When we arrive at a leaf, an output symbol is
% generated and the process restarts.
%  
% We shall use dynamic array allocation for the output array
% data_decoded. 
% If the array is filled, it is replaced with an array twice as long.
% At the end, the array is shortened to the appropriate size.
% The initial output array size is determined based on the maximum code
% word length.
% 
% Variable len is the length of the output array and j 
% is an index to the current position in it, while index points
% to the current node in the coding tree.

len = max( 1000, floor(length(data_encoded)/code.longest) );
data_decoded = zeros( len, 1 );

j = 1;
index = code.root;
for i = 1:length(data_encoded)
  if data_encoded(i)==1
    index = code.one(index-code.size);
  else
    index = code.zero(index-code.size);
  end

% Indexes smaller than code.size represents a leaf, so we output 
% the decoded symbol, growing data_decoded if necessary.

  if index<=code.size
    if j>len
      data_decoded = [data_decoded; zeros(len,1)];
      len = 2*len;
    end
    data_decoded(j) = code.values(index);
    j = j+1;
    index = code.root;
  end
end

% The array is shortened and code.offset taken into account.

data_decoded = data_decoded(1:j-1) - code.offset;
